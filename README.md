# phase-Extender
a python program that takes in ReadBack phased haplotypes and returns extended haplotype blocks


# further Updates, tutorials and documentation changes expected soon.

# pHASE-Extender
## Introduction
**a python program to extend the ReadBack phased haplotypes using first order transition probabilities.**

This program is designed to extend the haplotypes using the phased genotypes (allele) states of paritally phased F1 hybrids. It exclusively uses the `Phased Genotype i.e PG` and `Phase Block Index i.e PI` generated by the program `pHASER` https://github.com/secastel/phaser , https://github.com/secastel/phaser/tree/master/phaser

# Q/A on phase extender: 

  **1) How is phase Extender different than other gw (genome wide) haplotype phasing program ?**
    There are lots of GW haplotype phasing program, which are mostly built for human genome (modern or ancient). So, they 
    rely moslty on huge amount of genotype data and available haplotype reference panel. I don't know much detail on the 
    alrorithm that is used in those programs. But, phase-extender is built for extending the already existing short 
    haplotypes which come from short reads alignment. So, phase extender is most suitable for non-model organism, or 
    emerging model organism or for organism for which haplotype reference panel doesn't exist. 
    
  **2) What kind of algorith does phase-extender use ? **
    phase-extender uses first order transition probabilities matrix from each level of genotypes from former haplotype 
    block to each level of genotypes to later haplotype block. 
    At the moment phase-extender only uses **forward-1stOrder-markov chains** transition probabilities. I soon plan to 
    improve the algorithm by adding **backward-1stOrder-markov chains** transition probabilities. These may follow
    improvements by adding markov chains of higher order.
    
    
   **3) What is the advantage of using phase-extender? **
    We generally need accurate phase state with in a gene/transcript level. Using short reads we can call SNPs and have small haplotype
    blocks. But, these haplotype blocks may not be complete for a set of gene or for several genes within a QTL regions. phase-extender
    comes handy at these stage; that it takes the information from several haplotype blocks from other samples that are not broken at that
    point. So, that way we can solve haplotype configuration for SOI (sample of interest) pretty much easily. Also, with paired-end read
    size getting increased in Illumina sequence data we can have more reliable full gene-level haplotypes for SOI.
    
   Does phase-extender phase InDels?
    Yes, but it only does so when the InDels is in the haplotype block that consists of SNPs.
    
   What is the minimal size of the haplotype block that is required?
    The bigger the two haplotypes, the better is the likelyhood test of which haplotype is phased with which. By, default
    I have kept this number to 3 variants (SNPs exclusive) per haplotype block that needs extension.
    
   Does phase-extender do GW (genome wide) or CW (chromosome wide) haplotype phasing?
    There are certain situation when phase-extender is able to do GW or CW haplotype phasing.
    A) If you have lots of samples where the haplotypes overlap between sample covers almost all chromosome length. In this
       case we can run phase-extender for each sample there by extending the haplotype. After this phase-extender can be 
       applied recursively on the updated data each time, there by extending the haplotypes for each sample to full chromosome
       length and possibly to to full genome wide length. This is going to be more and more possible due to samples being
       sequenced at higher coverage, increase in the size of paired-end sequence length, availability of large sequence reads
       like pac-bio reads. The method for doing is explained in this link/website ..... ??
       
    B) Another situation when GW/CW phase extension might be possible is when you have at least few samples which have haplotype 
       resolved at GW/CW level. These can include fully phased data like genome matrix file, fully phased VCF data, fully phased
       haplotype blocks. For this the fully phased sample should be provided as one single blocks in the group of sample that is
       fed to phase-extender. Here is an example.... ??
       
   Does phase-extender phase the SNPs that are not phased to any other SNPs?
    For, now phase-extender doesn't have algorithm built into it to do so. I am hoping to add that ASAP.
      
   Does phase-extender impute missing genotypes?
    No, it does not. I have not developed any algorithm so far to impute missing genotypes. Should anyone be interested in 
    developing an algorithm, and have data to do so; I would be more than happy to.  
    
   Does phase-extender use haplotype reference panel?
    No, until now. Though it should be possible in near future.
   
   Does phase-extender use recombination into account?
    No and possibly these feature will be of least importance in phase-extender. Phase-Extender mostly relies on already       
    phased haplotype block from other samples. These haplotype blocks which were phased in other sample but in SOI were used 
    to build transition probabilities. There is strong assumption that variation in other samples are not the result of 
    recombination but only mutation.
    
   Does phase-extender phase rare genotypes?
    Yes, it does. But, the rare genotype should be the part (phased to) of phased haplotype blocks. This is one of the good 
    thing about phase-extender compared to other tools when it come to rare genotype. When several SNPs are phased together 
    to extend the haplotype, rare genotypes are really hard to phase accurately - the reason being the statistical 
    significance of the rare genotype belonging to either two phase state is highly ambigous. But, if the rare genotype is 
    attached to a haplotye block supported by read-back phasing, this makes phasing of rare genotypes most accurate, since 
    the likely hoods are provided by other SNPs that are not rare.
    
   How fast is phase-extender?
    phase-extender is written in python-3, so it is slower than other tools that are built on the top of C, C++ or java.   
    Coming from a pure biology background, learning python was one of the most enduring task I have taking and then 
    building this tool was a big part of my PhD. I have optimized the part of calling VCF file using cyvcf2 (which is on 
    average 4 times faster than old pyVCF module). phase-extender is also optimized for being able to run on multiple 
    threads/process. But, if you are running phase-extender on big genome data and have very large number of samples, and    
    running on laptop I suggest running on one thread, which may be time consuming but will reduce memory burden.
    
   Who helped me during the preparation of this program?
    I have not been very fortunate to surround myself or at least get face to face help from savvy computer programmers.
    But, my heart is very thankful to people behind the web who have made me capable of working this problem out - Thanks 
    to many people on biostars, stackoverflow, seqanswer and google web searches.
   
   
## Note:
- Basically this tool takes the paritally phased haplotypes
    - segregates them to maternal vs. paternal population haplotypes (using markov model)
    - stitches the haplotypes to create a genome wide haplotype
    
This program is exclusively designed to phase haplotypes in F1 hybrid for now and should work equally with data generated from genome reseq, RNAseq, WES or RAD given the individual is a hybrid derived from divergent strains and/or populations, but may be used to equally extended to phase F2 hybrids (work on progress).

# Prerequisites:
Python packages and modules
- Python3 (https://www.python.org/)
- pandas (http://pandas.pydata.org/)
- io
- pyvcf (https://github.com/jamescasbon/PyVCF)
- itertools
- collections
- functools

# Running phase-Stitcher

## Usage (**using the given test data in the example folder**): 

    python Stitcher_using_1stOrderMarkov_InteractiveMode.py --vcf1 MY_subSample.vcf --vcf2 SP_subSample.vcf --pop1 My --pop2 Sp --output test --het_vcf F1_subSample.vcf --f1_sample 2ms04h


